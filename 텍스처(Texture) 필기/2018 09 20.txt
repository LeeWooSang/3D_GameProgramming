- 렌더 타겟
RTV(렌더타겟뷰)는 최대 8개까지 set할 수 있다.
DSV(Depth_Stencil_View)는 최대 1개

만약 렌더타겟이 최대 8개까지 있을 때, 다중 렌더 타겟을 랜더하는 것이다.
=> 픽셀셰이더에서 리턴값이 구조체를 리턴한다. 그 구조체의 멤버변수들이 각각 Color값이 아니라
벡터로 생각을해서, 각 멤버 변수마다 시멘틱을 달아준다.
ex) SV_Target0, SV_Target1, SV_Target2 ... 
이렇게하면 Output 머저가 알아서 후면버퍼에 출력한다.

렌더타겟은 write용도로 사용하는 것이다.
후면버퍼에 write한 정보를 read를 할 수 있어야 한다. read를 하기 위해서는 셰이더 리소스 뷰를 통해 읽는다.
=> 읽기 위한 용도 상수버퍼뷰, 셰이더리소스뷰, 샘플러..

텍스처는 셰이더리소스뷰(SRV)에 만들면 셰이더에서 읽고 쓸 수 있다. 
읽는 방법
- 응용프로그램에서 Write한 데이터를 읽기 위해서는 Read힙에 만들어 Map하여 읽으면 된다.
- 또는 

< 후면버퍼 >
On Screen 버퍼 : 안의 값을 바꾸면 모니터로 보이는 버퍼
Off Screen 버퍼 : 값을 바꾸어도 모니터에는 보이지 않는 버퍼 => G(Geometry)-버퍼 라고 부름

RTV를 Off Screen 버퍼에 그려 놓고, 그려 놓은 것을 PS 1 (픽셀 셰이더 1)에서 값을 바꾸어
그 것들을 On Screen 버퍼에 연결하면 된다. 
=> 즉 화면에 보여주기 전에 셰이더에서도 읽고 쓰기 동작을 할 수 있다.

< 물체의 윤곽선(edge)을 셰이더에서만 그리게 하는 방법 >
면과 면 사이에 있는 경계선(edge) 부분에는 법선 벡터 차이가 크다.
즉, 픽셀로 얘기를 하면, 주변의 픽셀들의 법선벡터들의 평균값과 구하려는 부분의 픽셀의 법선벡터가 같지
않으면, 그 부분이 경계선이다.
또는 프리미티브 아이다가 같은지 같지 않은지로도 알 수 있다. 
=> 픽셀셰이더에서 어느 픽셀이 출력되는지 알 수 있는 방법
=> 버텍스셰이더에서 Output으로 리턴 된 값이 픽셀셰이더의 input이 될 때 픽셸 좌표가 들어있다. 
버텍스 셰이더의 position 좌표는 동차좌표계 x, y, z, w이지만, 픽셀 셰이더에서는 x, y만 들어 있음
(input.position.x, input.poistion.y)
=> 이것들은 렌더타겟에 있는 픽셸 좌표이다. 이것들을 렌더타겟에서는 쓰기위한 용도이므로, 정보를 읽지 못한다.
따라서, 픽셀셰이더에서 if문을 써서 법선벡터가 달라지는 픽셀 좌표를 다른 색깔로 출력하게하면 된다.
이렇게하면, 윤곽선은 다른 색깔로 표현할 수 있다.
그리고, 객체의 원래 색깔들은 2번 후면버퍼를 하나 더만들어서, 거기다 그려서, edge 조건을 만족하면, 1번 후면버퍼로
그리고, 만족하지 않으면 2번 후면버퍼를 이용하여 그리게 하면된다.

< 후처리(PostProcessing) >
GetDimensions( ) 함수는 사용하지 않는다. 
=> 사용하면, 픽셀셰이더는 그리는 모델의 폴리곤 숫자만큼 호출이 되는데, 텍스처의 크기를 계속 물어볼 필요가 없다.
따라서 밖에서 상수버퍼를 통해 넘겨주는 것이 훨씬 효율적이다.
