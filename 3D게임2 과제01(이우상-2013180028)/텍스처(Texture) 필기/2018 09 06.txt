텍스쳐를 읽기위해서는
1. Sampling 이 필요하다.

2. Filtering

재질은 매쉬가 가지고 있는 것이 아니다.

- Texture : uv좌표가 필요하다.
- 조명처리 : normal(법선벡터)가 필요

< ppt35 >

텍스쳐가 두개 있으면, 두개를 더하기/ 빼기 등 연산을 통하여
다른 색상을 표현할 수 있다.

샘플러 : 샘플링을 해주는 객체

struct D3D12_SAMPLER_DESC
- Filter : 샘플링 할 때, 필터링하는 방법


D3D12_FILTER
=> _MIN : 축소할 때,
=> _MAG : 확대할 때,
=> _MIP : 밉맵 레벨

- 점 필터링(point filtering) : 필터링을 하지 않은것
=> 소수 점의 좌표를 소수 점을 없애고 정수로 나타내서 표현

- 선형 필터링(Bilinear Filtering) : 
u좌표에 대해 리니어 인터폴레이션(보간)
v좌표에 대해 리니어 인터폴레이션(보간)

- 비등방 필터링 : 시간이 많이 걸려서, GPU에서 하드웨어적으로 처리한다.

< D3D12_TEXTURE_ADDRESS_MODE >

1. WRAP 모드 : 반복되는 문양 같은 텍스쳐를 반복시킨다. 
=> 정수 값이 음수여도 절대 값으로 계산하여 상관 없음
(uv 좌표가 -2 ~ 2 라고 할 때)
2. MIRROR 모드 : 1 - 텍스쳐 좌표에서 읽으면 거울반사처럼 보임
3. CLAMP 모드 : 0보다 작으면 0의 텍셀, 1보다 크면 1의 텍셀로 선택되는 모드
4. BORDER 모드 : 0부터 1까지는 텍스쳐를 매핑하고 1을 넘어가는 부분은 액자처럼
보이게하는 모드(색깔을 지정할 수 있다.)
5. MIRROR_ONCE 모드 : 한번 MIRROR 모드로 대칭하여 표현하고, 나머지는 CLAMP모드로 표현

루트시그니쳐_DESC에
STATIC_SAMPLER를 사용하면 따로 샘플러를 만들지 않아도 됨
따라서 CreateSampler함수를 사용하지 않아도 됨.

샘플러는 레지스터 번호를 s를 사용






