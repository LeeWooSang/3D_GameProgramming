< 기하 셰이더 >
객체를 그릴 때, GPU 인스턴싱 방법으로 객체를 그린다.
"DrawCall"이 많을 수록 랜더링이 느려진다 => 프레임레이트가 떨어짐
만약, 그리기 전에, DepthTest를 먼저 판단하여 안보이는 애들은 미리 판단하여 안그리게 하고,
절두체 컬링을 사용하여, 안보이는지 보이는지 판단하게 할 수 도 있다. 그러나 이것도 문제점이
있음

따라서 DrawCall을 줄여야 한다. 그러나 배치처리를 한다고 DrawCall이 줄어드는 것은 아니다.
배치 처리는 상태 변화를 적게하는 것이므로 DrawCall이 줄어들 지 않음
DrawCall을 줄이려면, 인스턴싱 방법이 있다.

인스턴싱 : DrawCall을 한번만 하면서, 똑같은 객체를 여러개를 한번에 그릴 수 있다.
=> 대신에 메쉬정보가 똑같아야 한다.

그러나 항상 인스턴싱을 사용하는게 정답은 아니다.
빌보드 사각형인 경우에 메쉬정보를 넘길 때, 점6개를 넘기는게 아니라, 점1개만 넘겨서
그 점에 월드변환행렬을 포함시킨다. 그리고 그 점에 Primitive ID 로 구분하여, 사각형을 
그려서 셰이더에 정보를 넘길때, 월드변환행렬을 따로 안넘기는 일을 해도 된다.

1차원 텍스처를 이용하여, 인스턴싱을 할 수 있다.
=> 1차원 텍스처에는 메시 정보, 월드변환행렬 정보를 포함시키는 방법

기하셰이더를 사용하면 새로운 프리미티브를 만들 수 있다.
기하셰이더에서는 새로운 정점을 생성할 수 있다(tristip, Iinestrip, pointlist)
기하셰이더에서는 정점셰이더에 있는 프리미티브 말고 새로운 정점들을 만들때 사용한다.

기하셰이더에서는 입력조립기에서 처리하려는 프리미티브를 알 수있다. 
SV_PrimitiveID를 이용하면 됨.

뷰포트를 이제까지는 1개만 사용했지만, 여러개를 사용하면, 그것들은 기하셰이더에서 사용할
수 있다. 최대 16개까지 설정 가능 => 사용할때, SV_ViewportArrayIndex를 사용함

SV_RenderTargetArrayIndex를 이용하여, 랜더타겟이 1개 이상일 때, 인덱스로 원하는 랜더타겟에
기하셰이더를 적용할 수 있다.

기하셰이더를 사용할 때는, [ ]기호로 컴파일러에게 미리 알려줘야 한다.
기하셰이더의 리턴타입은 항상 void임

모든 출력은 Strip으로 출력된다.

=> 기하셰이더의 장점이자 사용하는 이유는 없는 새로운 정점을 만들어 낼 수 있는 것!!
새로운 정점이 원래의 정점이 있는 선분에 있지않고, 다른 곳에 있게하려면(새로운 정점이
튀어나오게 하려면) 그 선분의 법선벡터를 곱하면 된다. 그러면 점이 선분위에 있지않아
튀어나와있는 모양으로 나타낼 수 있다.

=> 기하셰이더로 빌보드 나무를 표현하는 방법
점하나로 빌보드 사각형을 그리기
점에는 위치정보와, Size : 크기 두개를 포함시킨다.




